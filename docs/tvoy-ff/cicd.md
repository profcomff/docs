# CI/CD

## Что это такое?
Непрерывная интеграция (Continuous Integration, CI) и непрерывная поставка (Continuous Delivery, CD) представляют собой культуру, набор принципов и практик, которые позволяют разработчикам чаще и надежнее развертывать изменения программного обеспечения.

Непрерывная интеграция — это методология разработки и набор практик, при которых в код вносятся небольшие изменения с частыми коммитами. И поскольку большинство современных приложений разрабатываются с использованием различных платформ и инструментов, то появляется необходимость в механизме интеграции и тестировании вносимых изменений.

С технической точки зрения, цель CI — обеспечить последовательный и автоматизированный способ сборки, упаковки и тестирования приложений. При налаженном процессе непрерывной интеграции разработчики с большей вероятностью будут делать частые коммиты, что, в свою очередь, будет способствовать улучшению коммуникации и повышению качества программного обеспечения.

Непрерывная интеграция и непрерывная поставка нуждаются в непрерывном тестировании, поскольку конечная цель — разработка качественных приложений. Непрерывное тестирование часто реализуется в виде набора различных автоматизированных тестов (регрессионных, производительности и других), которые выполняются в CI/CD-конвейере.

Подробности о работе контура с точки зрения инфраструктуры можно посмотреть в разделе `Сервера и инфраструктура`

## Куда прятать секреты и переммнные
В каждом репозитории можно создать окружение. Базово у нас их два: тестовое и продакшн.

Чтобы найти их зайдите в любой репозиторий на GitHub в нашей организации, например в [auth-api](https://github.com/profcomff/auth-api). Отройте настройки, перейдите там в `Enviroments`. Тут лежат нужные вам окружения. Если вы создаете проект с нуля, вам надо создать окружения.

Перейдя в одно из окружений вы увидите `Environment secrets` и `Environment variables`. Секреты нужны для хранения конфеденциальной информации, их можно __только записывать__ и то, при наличии прав на это. Переменные же доступны на чтение, тно тоже нужны права на это.

В этой вкладке можно создать как переменные, так и секреты.

Из CI/CD к ним обращаться можно так:
1. Определить окружение, из которого идет обращение. Сделать это можно через ключ `jobs.<job>.environment`: <https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#jobsjob_idenvironment>
2. Обращение ведется так:
    К переменным: `'${{ vars.VAR_NAME }}'`

    К секретам: `'${{ secrets.SECRET_NAME }}'`

## Где взять секреты к PyPI, NPM
Они лежат в секретах организации. 

1. Перейдите в организацию
2. Зайдите в настройки
3. Перейдите в раздел `Secrets and variables` -> `Actions`
    Там вы увидите созданные токены: `NPM_TOKEN` и `PYPI_API_TOKEN`.

    Если вам нужен токен в репозитории, проверьте, что этому репозиторию он виден.
4. Обращение стандартное: `${{ secrets.PYPI_API_TOKEN }}`


## Описание работы стандартных пайплайнов
Пайплайны описаваются в формате `yaml`. Синтаксис и документация доступна тут: <https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions>

### Проверки стилей и тесты Python
Пример доступен тут: <https://github.com/profcomff/auth-api/blob/main/.github/workflows/checks.yml>

[Эти две строки](https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/checks.yml#L3) означают, что пайплайн будет запускаться на каждый Pull Request

Перейдем к описанию `job` под названием `tests`: <https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/checks.yml#L7>

Job запускается на машинках GitHub, требует как сервис `postgres:15`.

1 шаг это checkout репозитория, потом настраивается python конкретной версии. После этого устанавливается `pip` и зависимости для проекта, делается миграция базы данных и запускаются тесты. 

Тесты запускаются с расширением, которое позволяет определять покрытие тестами кода. После этого печатается отчет о тестах, пишется комментарий в Pull Request и совершается выход.

Перейдем к описанию `job` под названием `linting`: <https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/checks.yml#L63>

Начинается оно так же, как и тесты, но после настройки python запускается `isort` и `black`. После этого пишется коментарий, если код содержит места, не соответствующие правилам оформления.

### Проверки стилей и тесты Node.js
Пример доступен тут: <https://github.com/profcomff/webapp-ui/blob/main/.github/workflows/pr_create.yml>

[Эта строка](https://github.com/profcomff/webapp-ui/blob/2fd8ba0240d316107ae2cd066879c3f5e7514d1c/.github/workflows/pr_create.yml#L3) означает, что пайплайн будет запускаться на каждый Pull Request

Перейдем к описанию `job` под названием `test`(Проверяем стили)

Все почти то же самое, что и в Python: checkout репозитория, установка `pnpm`, установка `node.js`, зависимостей и дальше идет запуск проверки стилей.

Перейдем к описанию `job` под названием `test-format`(Выполняем тесты)

Все очень похоже, но в конце запускается не проверка стилей, а тесты

### Билд библиотек и пуш их в PyPI
Пример доступен тут: <https://github.com/profcomff/auth-lib/blob/main/.github/workflows/build_and_publish.yml>

В начале прописано, что пайплайн запускается на создание тега, начинающегося с буквы `v`, например: `v2024.01.02`

Сначала происходит checkout репозитория и настройка python, далее происходит замена текста в файле `auth_lib/__init__.py`, там заменяется версия на ту, что указана в теге.

Далее устанавливаются зависимости и билдится библиотека. Документация по билду python библиотек есть тут: <https://packaging.python.org/en/latest/tutorials/packaging-projects/>

Далее собранный пакет загружается на PyPI, используя секретный токен, находящийся в секретах организации.

### Билд библиотек и пуш их в NPM
Пример доступен тут: <https://github.com/profcomff/api-uilib/blob/main/.github/workflows/publish.yaml>

В начале прописано, что пайплайн запускается на создание тега, начинающегося с буквы `v`, например: `v2024.01.02`

Сначала происходит checkout репозитория, настройка `pnpm` и `node.js`, установка зависимостей.

Следующим шагом меняется версия пакета на ту, что пришла из тегов GitHub

Далее библиотека собирается и загружается в NPM.

### Build and push docker image
Пример доступен тут: <https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/build_and_publish.yml#L15>

Данный пайплайн собирает докер образ и загружает его в `ghrc` - гитхабовское облако образов.

Начинается пайплайн с checkout репозитория, далее идет вход в docker registry.

После этого мы запрашиваем метаданные из registry по версиям: тестовой и продовой.

Далее собираем и пушим образ в registry.

### Разварачивание в тестовое и продакшн окружение
Пример доступен тут, для тестового окружения: <https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/build_and_publish.yml#L53>

И тут, для продакшна: <https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/build_and_publish.yml#L136>

Данный пайплайн забирает образ тестовый из ghrc и деплоит его на сервер.

Единственный два action'а, которые запускаются на наших серверах.

Начинается он с [определения окружения](https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/build_and_publish.yml#L59), которое должно существовать в настройках репозитория. 

Шаги в action простые: забираем с `ghrc` новую версию, мигрируем базу данных, останавливаем предудыщий контейнер, запускаем новый контейнер с нужными переменными окружения.

Продакшн пайплайн идентичен, за исключением того, что он запускается на другом сервере и для его запуска нужен тег: <https://github.com/profcomff/auth-api/blob/1361a58f72ce7817e710ecdec1bdff580596f7a7/.github/workflows/build_and_publish.yml#L139>

## Ссылки
[Про написание пайплайнов к GitHub Actions](https://habr.com/ru/articles/711278/)

[Официальный Quick Start](https://docs.github.com/ru/actions/writing-workflows/quickstart)
